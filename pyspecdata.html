

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>N-dimensional Data (nddata) &mdash; pySpecData 0.9.5.1.6 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pySpecData 0.9.5.1.6 documentation" href="index.html"/>
        <link rel="up" title="LaTeX Notebook Functionality" href="notebook.html"/>
        <link rel="next" title="Axis Manipulation Functions" href="axis_manipulation.html"/>
        <link rel="prev" title="LaTeX Notebook Functionality" href="notebook.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pySpecData
          

          
          </a>

          
            
            
              <div class="version">
                0.9.5.1.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="modules.html">List of Modules and Sub-Packages</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="notebook.html">LaTeX Notebook Functionality</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="notebook.html#setting-up-the-notebook">Setting up the notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebook.html#running-the-notebook">Running the notebook</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="notebook.html#how-it-works">How it works</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="notebook.html#the-latex-end">The LaTeX end</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="notebook.html#the-python-end">The python end</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">N-dimensional Data (nddata)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#full-list-of-nddata-methods">Full list of <cite>nddata</cite> methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="latexscripts.html">Documentation of Notebook Helper Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nddata.html">ND-Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="figlist.html">The Figure List</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pySpecData</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="notebook.html">LaTeX Notebook Functionality</a> &raquo;</li>
        
      <li>N-dimensional Data (nddata)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/pyspecdata.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="n-dimensional-data-nddata">
<h1>N-dimensional Data (nddata)<a class="headerlink" href="#n-dimensional-data-nddata" title="Permalink to this headline">¶</a></h1>
<div class="section" id="by-topic">
<h2>By Topic<a class="headerlink" href="#by-topic" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="axis_manipulation.html">Axis Manipulation Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fourier.html">Fourier Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nddata.html">ND-Data</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="full-list-of-nddata-methods">
<h1>Full list of <cite>nddata</cite> methods<a class="headerlink" href="#full-list-of-nddata-methods" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyspecdata.nddata">
<em class="property">class </em><code class="descclassname">pyspecdata.</code><code class="descname">nddata</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the detailed API reference.
For an introduction on how to use ND-Data, see the <a class="reference internal" href="nddata.html#nddata-summary-label"><span class="std std-ref">Main ND-Data Documentation</span></a>.</p>
<dl class="method">
<dt id="pyspecdata.nddata.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize nddata – several options.
Depending on the information available, one of several formats can be used.</p>
<dl class="docutils">
<dt>3 arguments:</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">nddata(inputarray,</span> <span class="pre">shape,</span> <span class="pre">dimlabels)</span></code></p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">inputarray:</th><td class="field-body">ndarray storing the data – note that the size is ignored
and the data is reshaped as needed</td>
</tr>
<tr class="field-even field"><th class="field-name">shape:</th><td class="field-body">a list (or array, <em>etc.</em>) giving the size of each dimension, in order</td>
</tr>
<tr class="field-odd field"><th class="field-name">dimlabels:</th><td class="field-body">a list giving the names of each dimension, in order</td>
</tr>
</tbody>
</table>
</dd>
<dt>2 arguments:</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">nddata(inputarray,</span> <span class="pre">dimlabels)</span></code></p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">inputarray:</th><td class="field-body">ndarray storing the data – the data is <em>not</em> reshaped</td>
</tr>
<tr class="field-even field"><th class="field-name">dimlabels:</th><td class="field-body">a list giving the names of each dimension, in order</td>
</tr>
</tbody>
</table>
</dd>
<dt>2 arguments:</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">nddata(inputarray,</span> <span class="pre">single_dimlabel)</span></code></p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">inputarray:</th><td class="field-body">ndarray storing the data – must be 1D
inputarray is <em>also</em> used to label the single axis</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">single_dimlabel:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">a list giving the name of the single axis</td>
</tr>
</tbody>
</table>
</dd>
<dt>1 argument:</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">nddata(inputarray,</span> <span class="pre">shape,</span> <span class="pre">dimlabels)</span></code></p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">inputarray:</th><td class="field-body">ndarray storing the data – reduced to 1D
A single dimension, called “INDEX” is set.
This suppresses the printing of axis labels.
This is used to store numbers and arrays
that might have error and units,
but aren’t gridded data.</td>
</tr>
</tbody>
</table>
</dd>
<dt>keyword args</dt>
<dd>these can be used to set the labels, etc, and are passed to <code class="xref py py-func docutils literal"><span class="pre">__my_init__()</span></code></dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.__init__" title="pyspecdata.nddata.__init__"><code class="xref py py-obj docutils literal"><span class="pre">__init__</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>initialize nddata – several options.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.add_noise" title="pyspecdata.nddata.add_noise"><code class="xref py py-obj docutils literal"><span class="pre">add_noise</span></code></a>(intensity)</td>
<td>Add Gaussian (box-muller) noise to the data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.aligndata" title="pyspecdata.nddata.aligndata"><code class="xref py py-obj docutils literal"><span class="pre">aligndata</span></code></a>(arg[,&nbsp;verbose])</td>
<td>This is a fundamental method used by all of the arithmetic operations.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.argmax" title="pyspecdata.nddata.argmax"><code class="xref py py-obj docutils literal"><span class="pre">argmax</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>find the max along a particular axis, and get rid of that axis, replacing it with the index number of the max value</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.argmin" title="pyspecdata.nddata.argmin"><code class="xref py py-obj docutils literal"><span class="pre">argmin</span></code></a>(axes[,&nbsp;raw_index])</td>
<td>find the min along a particular axis, and get rid of that axis, replacing it with the index number of the min value</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.angle" title="pyspecdata.nddata.angle"><code class="xref py py-obj docutils literal"><span class="pre">angle</span></code></a></td>
<td>Return the angle component of the data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.axis" title="pyspecdata.nddata.axis"><code class="xref py py-obj docutils literal"><span class="pre">axis</span></code></a>(axisname)</td>
<td>returns a 1-D axis for further manipulation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.axlen" title="pyspecdata.nddata.axlen"><code class="xref py py-obj docutils literal"><span class="pre">axlen</span></code></a>(axis)</td>
<td>return the size (length) of an axis, by name</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.axn" title="pyspecdata.nddata.axn"><code class="xref py py-obj docutils literal"><span class="pre">axn</span></code></a>(axis)</td>
<td>Return the index number for the axis with the name “axis”</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.cdf" title="pyspecdata.nddata.cdf"><code class="xref py py-obj docutils literal"><span class="pre">cdf</span></code></a>([normalized,&nbsp;max_bins])</td>
<td>calculate the Cumulative Distribution Function for the data along <cite>axis_name</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.check_axis_coords_errors.html#pyspecdata.nddata.check_axis_coords_errors" title="pyspecdata.nddata.check_axis_coords_errors"><code class="xref py py-obj docutils literal"><span class="pre">check_axis_coords_errors</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.chunk" title="pyspecdata.nddata.chunk"><code class="xref py py-obj docutils literal"><span class="pre">chunk</span></code></a>(axisin,&nbsp;*otherargs)</td>
<td>“Chunking” is defined here to be the opposite of taking a direct product, increasing the number of dimensions by the inverse of the process by which taking a direct product decreases the number of dimensions.  This function chunks axisin into multiple new axes arguments.:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.chunk_auto" title="pyspecdata.nddata.chunk_auto"><code class="xref py py-obj docutils literal"><span class="pre">chunk_auto</span></code></a>(axis_name,&nbsp;which_field[,&nbsp;…])</td>
<td>assuming that axis “axis_name” is currently labeled with a structured array, choose one field (“which_field”) of that structured array to generate a new dimension</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.chunkoff" title="pyspecdata.nddata.chunkoff"><code class="xref py py-obj docutils literal"><span class="pre">chunkoff</span></code></a>(axisin,&nbsp;newaxes,&nbsp;newshapes)</td>
<td>Break chunks off of the dimension given by <cite>axisin</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.circshift.html#pyspecdata.nddata.circshift" title="pyspecdata.nddata.circshift"><code class="xref py py-obj docutils literal"><span class="pre">circshift</span></code></a>(axis,&nbsp;amount)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.contiguous" title="pyspecdata.nddata.contiguous"><code class="xref py py-obj docutils literal"><span class="pre">contiguous</span></code></a>(lambdafunc[,&nbsp;axis,&nbsp;verbose])</td>
<td>Return contiguous blocks that satisfy the condition given by <cite>lambdafunc</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.contour" title="pyspecdata.nddata.contour"><code class="xref py py-obj docutils literal"><span class="pre">contour</span></code></a>([labels])</td>
<td>Contour plot – kwargs are passed to the matplotlib <cite>contour</cite> function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.convolve" title="pyspecdata.nddata.convolve"><code class="xref py py-obj docutils literal"><span class="pre">convolve</span></code></a>(axisname,&nbsp;filterwidth[,&nbsp;convfunc])</td>
<td>Perform a convolution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.copy" title="pyspecdata.nddata.copy"><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code></a>([data])</td>
<td>Return a full copy of this instance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.copyaxes.html#pyspecdata.nddata.copyaxes" title="pyspecdata.nddata.copyaxes"><code class="xref py py-obj docutils literal"><span class="pre">copyaxes</span></code></a>(other)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.cropped_log" title="pyspecdata.nddata.cropped_log"><code class="xref py py-obj docutils literal"><span class="pre">cropped_log</span></code></a>([subplot_axes,&nbsp;magnitude])</td>
<td>For the purposes of plotting, this generates a copy where I take the log, spanning “magnitude” orders of magnitude</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.diff.html#pyspecdata.nddata.diff" title="pyspecdata.nddata.diff"><code class="xref py py-obj docutils literal"><span class="pre">diff</span></code></a>(thisaxis[,&nbsp;backwards])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.extend" title="pyspecdata.nddata.extend"><code class="xref py py-obj docutils literal"><span class="pre">extend</span></code></a>(axis,&nbsp;extent[,&nbsp;fill_with,&nbsp;tolerance,&nbsp;…])</td>
<td>If <cite>axis</cite> is uniformly ascending with spacing <span class="math">\(dx\)</span>, then extend by adding a point every <span class="math">\(dx\)</span> until the axis includes the point <cite>extent</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.extend_for_shear" title="pyspecdata.nddata.extend_for_shear"><code class="xref py py-obj docutils literal"><span class="pre">extend_for_shear</span></code></a>(altered_axis,&nbsp;propto_axis,&nbsp;…)</td>
<td>this is propto_axis helper function for <cite>.fourier.shear</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.fld" title="pyspecdata.nddata.fld"><code class="xref py py-obj docutils literal"><span class="pre">fld</span></code></a>(dict_in[,&nbsp;noscalar])</td>
<td>flatten dictionary – return list.  This is the inverse of <a class="reference internal" href="#pyspecdata.nddata.mkd" title="pyspecdata.nddata.mkd"><code class="xref py py-func docutils literal"><span class="pre">nddata.mkd()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.fourier_shear" title="pyspecdata.nddata.fourier_shear"><code class="xref py py-obj docutils literal"><span class="pre">fourier_shear</span></code></a>(altered_axis,&nbsp;propto_axis,&nbsp;…)</td>
<td>the fourier shear method – see .shear() documentation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.fromaxis" title="pyspecdata.nddata.fromaxis"><code class="xref py py-obj docutils literal"><span class="pre">fromaxis</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Generate an nddata object from one of the axis labels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.ft" title="pyspecdata.nddata.ft"><code class="xref py py-obj docutils literal"><span class="pre">ft</span></code></a>(axes[,&nbsp;tolerance,&nbsp;cosine,&nbsp;verbose])</td>
<td>This performs a Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.ft_clear_startpoints" title="pyspecdata.nddata.ft_clear_startpoints"><code class="xref py py-obj docutils literal"><span class="pre">ft_clear_startpoints</span></code></a>(axis[,&nbsp;t,&nbsp;f,&nbsp;verbose])</td>
<td>clears memory of where the origins in the time and frequency domain are this is useful, e.g. when you want to ift and center about time=0 by setting shift=True you can also manually set the points:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.ftshift" title="pyspecdata.nddata.ftshift"><code class="xref py py-obj docutils literal"><span class="pre">ftshift</span></code></a>(axis,&nbsp;value)</td>
<td>FT-based shift.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.get_covariance" title="pyspecdata.nddata.get_covariance"><code class="xref py py-obj docutils literal"><span class="pre">get_covariance</span></code></a>()</td>
<td>this returns the covariance matrix of the data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.get_error" title="pyspecdata.nddata.get_error"><code class="xref py py-obj docutils literal"><span class="pre">get_error</span></code></a>(*args)</td>
<td>get a copy of the errors</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.get_ft_prop" title="pyspecdata.nddata.get_ft_prop"><code class="xref py py-obj docutils literal"><span class="pre">get_ft_prop</span></code></a>(axis[,&nbsp;propname])</td>
<td>Gets the FT property given by <cite>propname</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.get_plot_color.html#pyspecdata.nddata.get_plot_color" title="pyspecdata.nddata.get_plot_color"><code class="xref py py-obj docutils literal"><span class="pre">get_plot_color</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.get_prop" title="pyspecdata.nddata.get_prop"><code class="xref py py-obj docutils literal"><span class="pre">get_prop</span></code></a>(propname)</td>
<td>return arbitrary ND-data properties (typically acquisition parameters <em>etc.</em>) by name (<cite>propname</cite>)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.get_units.html#pyspecdata.nddata.get_units" title="pyspecdata.nddata.get_units"><code class="xref py py-obj docutils literal"><span class="pre">get_units</span></code></a>(*args)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.getaxis.html#pyspecdata.nddata.getaxis" title="pyspecdata.nddata.getaxis"><code class="xref py py-obj docutils literal"><span class="pre">getaxis</span></code></a>(axisname)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.getaxisshape.html#pyspecdata.nddata.getaxisshape" title="pyspecdata.nddata.getaxisshape"><code class="xref py py-obj docutils literal"><span class="pre">getaxisshape</span></code></a>(axisname)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.gnuplot_save.html#pyspecdata.nddata.gnuplot_save" title="pyspecdata.nddata.gnuplot_save"><code class="xref py py-obj docutils literal"><span class="pre">gnuplot_save</span></code></a>(filename)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.hdf5_write" title="pyspecdata.nddata.hdf5_write"><code class="xref py py-obj docutils literal"><span class="pre">hdf5_write</span></code></a>(h5path[,&nbsp;directory,&nbsp;verbose])</td>
<td>Write the nddata to an HDF5 file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.histogram.html#pyspecdata.nddata.histogram" title="pyspecdata.nddata.histogram"><code class="xref py py-obj docutils literal"><span class="pre">histogram</span></code></a>(*args,&nbsp;**kwargs)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.human_units.html#pyspecdata.nddata.human_units" title="pyspecdata.nddata.human_units"><code class="xref py py-obj docutils literal"><span class="pre">human_units</span></code></a>([verbose])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.ift" title="pyspecdata.nddata.ift"><code class="xref py py-obj docutils literal"><span class="pre">ift</span></code></a>(axes[,&nbsp;tolerance,&nbsp;verbose])</td>
<td>This performs a Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.inhomog_coords" title="pyspecdata.nddata.inhomog_coords"><code class="xref py py-obj docutils literal"><span class="pre">inhomog_coords</span></code></a>(direct_dim,&nbsp;indirect_dim[,&nbsp;…])</td>
<td>Apply the “inhomogeneity transform,” which rotates the data by <span class="math">\(45^{\circ}\)</span>, and then mirrors the portion with <span class="math">\(t_2&lt;0\)</span> in order to transform from a <span class="math">\((t_1,t_2)\)</span> coordinate system to a <span class="math">\((t_{inh},t_{homog})\)</span> coordinate system.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.integrate" title="pyspecdata.nddata.integrate"><code class="xref py py-obj docutils literal"><span class="pre">integrate</span></code></a>(thisaxis[,&nbsp;backwards,&nbsp;cumulative])</td>
<td>this performs an integration – which is similar to a sum, except that it takes the axis into account, i.e., it performs:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.interp" title="pyspecdata.nddata.interp"><code class="xref py py-obj docutils literal"><span class="pre">interp</span></code></a>(axis,&nbsp;axisvalues[,&nbsp;past_bounds,&nbsp;…])</td>
<td>interpolate data values given axis values</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.invinterp" title="pyspecdata.nddata.invinterp"><code class="xref py py-obj docutils literal"><span class="pre">invinterp</span></code></a>(axis,&nbsp;values,&nbsp;**kwargs)</td>
<td>interpolate axis values given data values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.labels" title="pyspecdata.nddata.labels"><code class="xref py py-obj docutils literal"><span class="pre">labels</span></code></a>(*args)</td>
<td>label the dimensions, given in listofstrings with the axis labels given in listofaxes – listofaxes must be a numpy array;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.linear_shear" title="pyspecdata.nddata.linear_shear"><code class="xref py py-obj docutils literal"><span class="pre">linear_shear</span></code></a>(along_axis,&nbsp;propto_axis,&nbsp;shear_amnt)</td>
<td>the linear shear – see <cite>self.shear</cite> for documentation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.matchdims" title="pyspecdata.nddata.matchdims"><code class="xref py py-obj docutils literal"><span class="pre">matchdims</span></code></a>(other)</td>
<td>add any dimensions to self that are not present in other</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.matrices_3d" title="pyspecdata.nddata.matrices_3d"><code class="xref py py-obj docutils literal"><span class="pre">matrices_3d</span></code></a>([also1d,&nbsp;invert,&nbsp;max_dimsize,&nbsp;…])</td>
<td>returns X,Y,Z,x_axis,y_axis</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.mayavi_surf" title="pyspecdata.nddata.mayavi_surf"><code class="xref py py-obj docutils literal"><span class="pre">mayavi_surf</span></code></a>()</td>
<td>use the mayavi surf function, assuming that we’ve already loaded mlab</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.mean" title="pyspecdata.nddata.mean"><code class="xref py py-obj docutils literal"><span class="pre">mean</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Take the mean and set the error to the standard deviation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.mean_all_but" title="pyspecdata.nddata.mean_all_but"><code class="xref py py-obj docutils literal"><span class="pre">mean_all_but</span></code></a>(listofdims)</td>
<td>take the mean over all dimensions not in the list</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.mean_nopop.html#pyspecdata.nddata.mean_nopop" title="pyspecdata.nddata.mean_nopop"><code class="xref py py-obj docutils literal"><span class="pre">mean_nopop</span></code></a>(axis)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.mean_weighted" title="pyspecdata.nddata.mean_weighted"><code class="xref py py-obj docutils literal"><span class="pre">mean_weighted</span></code></a>(axisname)</td>
<td>perform  the weighted mean along <cite>axisname</cite> (use $sigma$ from $sigma = $self.get_error() do generate $1/sigma$ weights)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.meshplot" title="pyspecdata.nddata.meshplot"><code class="xref py py-obj docutils literal"><span class="pre">meshplot</span></code></a>([stride,&nbsp;alpha,&nbsp;onlycolor,&nbsp;light,&nbsp;…])</td>
<td>takes both rotation and light as elevation, azimuth</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.mkd" title="pyspecdata.nddata.mkd"><code class="xref py py-obj docutils literal"><span class="pre">mkd</span></code></a>(*arg,&nbsp;**kwargs)</td>
<td>This is an internal function that accepts one of the internal attributes (axis_coords, etc) that are stored as lists, and return a list that is labeled with the dimlabels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.multimin.html#pyspecdata.nddata.multimin" title="pyspecdata.nddata.multimin"><code class="xref py py-obj docutils literal"><span class="pre">multimin</span></code></a>(minfunc,&nbsp;axisname,&nbsp;filterwidth,&nbsp;…)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.name" title="pyspecdata.nddata.name"><code class="xref py py-obj docutils literal"><span class="pre">name</span></code></a>(*arg)</td>
<td>args:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.normalize.html#pyspecdata.nddata.normalize" title="pyspecdata.nddata.normalize"><code class="xref py py-obj docutils literal"><span class="pre">normalize</span></code></a>(axis[,&nbsp;first_figure])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.oldtimey.html#pyspecdata.nddata.oldtimey" title="pyspecdata.nddata.oldtimey"><code class="xref py py-obj docutils literal"><span class="pre">oldtimey</span></code></a>([alpha,&nbsp;ax,&nbsp;linewidth,&nbsp;…])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.plot_labels" title="pyspecdata.nddata.plot_labels"><code class="xref py py-obj docutils literal"><span class="pre">plot_labels</span></code></a>(labels[,&nbsp;fmt])</td>
<td>this only works for one axis now</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.polyfit" title="pyspecdata.nddata.polyfit"><code class="xref py py-obj docutils literal"><span class="pre">polyfit</span></code></a>(axis[,&nbsp;order,&nbsp;force_y_intercept])</td>
<td>return the coefficients and the fit –&gt; later, should probably branch this off as a new type of fit class</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.popdim.html#pyspecdata.nddata.popdim" title="pyspecdata.nddata.popdim"><code class="xref py py-obj docutils literal"><span class="pre">popdim</span></code></a>(dimname)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.random_mask" title="pyspecdata.nddata.random_mask"><code class="xref py py-obj docutils literal"><span class="pre">random_mask</span></code></a>(axisname[,&nbsp;threshold,&nbsp;inversion])</td>
<td>generate a random mask with about ‘threshold’ of the points thrown out</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.real" title="pyspecdata.nddata.real"><code class="xref py py-obj docutils literal"><span class="pre">real</span></code></a></td>
<td>Return the real component of the data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.register_axis" title="pyspecdata.nddata.register_axis"><code class="xref py py-obj docutils literal"><span class="pre">register_axis</span></code></a>(arg)</td>
<td>Interpolate the data so that the given axes are in register with a set of specified values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.rename.html#pyspecdata.nddata.rename" title="pyspecdata.nddata.rename"><code class="xref py py-obj docutils literal"><span class="pre">rename</span></code></a>(previous,&nbsp;new)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.reorder" title="pyspecdata.nddata.reorder"><code class="xref py py-obj docutils literal"><span class="pre">reorder</span></code></a>(*axes,&nbsp;**kwargs)</td>
<td>Reorder the dimensions</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.replicate_units.html#pyspecdata.nddata.replicate_units" title="pyspecdata.nddata.replicate_units"><code class="xref py py-obj docutils literal"><span class="pre">replicate_units</span></code></a>(other)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.repwlabels.html#pyspecdata.nddata.repwlabels" title="pyspecdata.nddata.repwlabels"><code class="xref py py-obj docutils literal"><span class="pre">repwlabels</span></code></a>(axis)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.retaxis.html#pyspecdata.nddata.retaxis" title="pyspecdata.nddata.retaxis"><code class="xref py py-obj docutils literal"><span class="pre">retaxis</span></code></a>(axisname)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.run.html#pyspecdata.nddata.run" title="pyspecdata.nddata.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a>(*args)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.run_avg" title="pyspecdata.nddata.run_avg"><code class="xref py py-obj docutils literal"><span class="pre">run_avg</span></code></a>(thisaxisname[,&nbsp;decimation,&nbsp;centered])</td>
<td>a simple running average</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.run_nopop.html#pyspecdata.nddata.run_nopop" title="pyspecdata.nddata.run_nopop"><code class="xref py py-obj docutils literal"><span class="pre">run_nopop</span></code></a>(func,&nbsp;axis)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.runcopy.html#pyspecdata.nddata.runcopy" title="pyspecdata.nddata.runcopy"><code class="xref py py-obj docutils literal"><span class="pre">runcopy</span></code></a>(*args)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.set_error" title="pyspecdata.nddata.set_error"><code class="xref py py-obj docutils literal"><span class="pre">set_error</span></code></a>(*args)</td>
<td>set the errors: either</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.set_ft_prop" title="pyspecdata.nddata.set_ft_prop"><code class="xref py py-obj docutils literal"><span class="pre">set_ft_prop</span></code></a>(axis[,&nbsp;propname,&nbsp;value])</td>
<td>Sets the FT property given by <cite>propname</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.set_plot_color.html#pyspecdata.nddata.set_plot_color" title="pyspecdata.nddata.set_plot_color"><code class="xref py py-obj docutils literal"><span class="pre">set_plot_color</span></code></a>(thiscolor)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.set_prop" title="pyspecdata.nddata.set_prop"><code class="xref py py-obj docutils literal"><span class="pre">set_prop</span></code></a>(*args)</td>
<td>set a ‘property’ of the nddata</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.set_units.html#pyspecdata.nddata.set_units" title="pyspecdata.nddata.set_units"><code class="xref py py-obj docutils literal"><span class="pre">set_units</span></code></a>(*args)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.setaxis" title="pyspecdata.nddata.setaxis"><code class="xref py py-obj docutils literal"><span class="pre">setaxis</span></code></a>(axis,&nbsp;value)</td>
<td>set the value of the axis if you pass a function as the <cite>value</cite>, it will use the existing axis labels as the argument of the function, and then put the result into the axis labels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.shear" title="pyspecdata.nddata.shear"><code class="xref py py-obj docutils literal"><span class="pre">shear</span></code></a>(along_axis,&nbsp;propto_axis,&nbsp;shear_amnt[,&nbsp;…])</td>
<td>Shear the data <span class="math">\(s\)</span>:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.smoosh" title="pyspecdata.nddata.smoosh"><code class="xref py py-obj docutils literal"><span class="pre">smoosh</span></code></a>(dimstocollapse[,&nbsp;dimname,&nbsp;noaxis,&nbsp;…])</td>
<td>Collapse multiple dimensions into one dimension.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.sort.html#pyspecdata.nddata.sort" title="pyspecdata.nddata.sort"><code class="xref py py-obj docutils literal"><span class="pre">sort</span></code></a>(axisname[,&nbsp;reverse])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.sort_and_xy.html#pyspecdata.nddata.sort_and_xy" title="pyspecdata.nddata.sort_and_xy"><code class="xref py py-obj docutils literal"><span class="pre">sort_and_xy</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyspecdata.nddata.squeeze" title="pyspecdata.nddata.squeeze"><code class="xref py py-obj docutils literal"><span class="pre">squeeze</span></code></a>([verbose])</td>
<td>squeeze singleton dimensions – return a list of the labels for the axes that are dropped</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/pyspecdata.nddata.sum.html#pyspecdata.nddata.sum" title="pyspecdata.nddata.sum"><code class="xref py py-obj docutils literal"><span class="pre">sum</span></code></a>(axes)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.sum_nopop.html#pyspecdata.nddata.sum_nopop" title="pyspecdata.nddata.sum_nopop"><code class="xref py py-obj docutils literal"><span class="pre">sum_nopop</span></code></a>(axes)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.unitify_axis" title="pyspecdata.nddata.unitify_axis"><code class="xref py py-obj docutils literal"><span class="pre">unitify_axis</span></code></a>(axis_name[,&nbsp;is_axis])</td>
<td>this just generates an axis label with appropriate units</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.units_texsafe.html#pyspecdata.nddata.units_texsafe" title="pyspecdata.nddata.units_texsafe"><code class="xref py py-obj docutils literal"><span class="pre">units_texsafe</span></code></a>(*args)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyspecdata.nddata.unset_prop" title="pyspecdata.nddata.unset_prop"><code class="xref py py-obj docutils literal"><span class="pre">unset_prop</span></code></a>(arg)</td>
<td>remove a ‘property’</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/pyspecdata.nddata.waterfall.html#pyspecdata.nddata.waterfall" title="pyspecdata.nddata.waterfall"><code class="xref py py-obj docutils literal"><span class="pre">waterfall</span></code></a>([alpha,&nbsp;ax,&nbsp;rotation,&nbsp;color,&nbsp;…])</td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">want_to_prospa_decim_correct</span></code></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyspecdata.</code><code class="descname">nddata</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>This is the detailed API reference.
For an introduction on how to use ND-Data, see the <a class="reference internal" href="nddata.html#nddata-summary-label"><span class="std std-ref">Main ND-Data Documentation</span></a>.</p>
<dl class="attribute">
<dt id="pyspecdata.nddata.C">
<code class="descname">C</code><a class="headerlink" href="#pyspecdata.nddata.C" title="Permalink to this definition">¶</a></dt>
<dd><p>shortcut for copy</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.add_noise">
<code class="descname">add_noise</code><span class="sig-paren">(</span><em>intensity</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Gaussian (box-muller) noise to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>intensity</strong> (<em>double OR function</em>) – If a double, gives the standard deviation of the noise.
If a function, used to calculate the standard deviation of the noise from the data:
<em>e.g.</em> <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">max(abs(x))/10.</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.aligndata">
<code class="descname">aligndata</code><span class="sig-paren">(</span><em>arg</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.aligndata" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a fundamental method used by all of the arithmetic operations.
It uses the dimension labels of <cite>self</cite> (the current instance) and <cite>arg</cite> (an nddata passed to this method) to generate two corresponding output nddatas that I refer to here, respectively, as <cite>A</cite> and <cite>B</cite>.  <cite>A</cite> and <cite>B</cite> have dimensions that are “aligned” – that is, they are identical except for singleton dimensions (note that numpy automatically tiles singleton dimensions).  Regardless of how the dimensions of <cite>self.data</cite> and <cite>arg.data</cite> (the underlying numpy data) were ordered, <cite>A.data</cite> and <cite>B.data</cite> are now ordered identically, where dimensions with the same label (<cite>.dimlabel</cite>) correspond to the same numpy index.  This allows you do do math.</p>
<p>Note that, currently, both <cite>A</cite> and <cite>B</cite> are given a full set of axis labels, even for singleton dimensions.  This is because we’re assuming you’re going to do math with them, and that the singleton dimensions will be expanded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg</strong> (<a class="reference internal" href="generated/pyspecdata.core.nddata.html#pyspecdata.core.nddata" title="pyspecdata.core.nddata"><em>nddata</em></a>) – the nddata that you want to align to <cite>self</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>A</strong> (<em>nddata</em>) – realigned version of <cite>self</cite></li>
<li><strong>B</strong> (<em>nddata</em>) – realigned version of <cite>arg</cite> (the argument)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyspecdata.nddata.angle">
<code class="descname">angle</code><a class="headerlink" href="#pyspecdata.nddata.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle component of the data</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.argmax">
<code class="descname">argmax</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>find the max along a particular axis, and get rid of that axis, replacing it with the index number of the max value</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.argmin">
<code class="descname">argmin</code><span class="sig-paren">(</span><em>axes</em>, <em>raw_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>find the min along a particular axis, and get rid of that axis, replacing it with the index number of the min value</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.axis">
<code class="descname">axis</code><span class="sig-paren">(</span><em>axisname</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.axis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a 1-D axis for further manipulation</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.axlen">
<code class="descname">axlen</code><span class="sig-paren">(</span><em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.axlen" title="Permalink to this definition">¶</a></dt>
<dd><p>return the size (length) of an axis, by name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>axis</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – name of the axis whos length you are interested in</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.axn">
<code class="descname">axn</code><span class="sig-paren">(</span><em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.axn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index number for the axis with the name “axis”</p>
<p>This is used by many other methods.
As a simple example,
self.:func:<cite>axlen`(axis) (the axis length) returns
``shape(self.data)[self.axn(axis)]`</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>axis</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – name of the axis</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.cdf">
<code class="descname">cdf</code><span class="sig-paren">(</span><em>normalized=True</em>, <em>max_bins=500</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the Cumulative Distribution Function for the data along <cite>axis_name</cite></p>
<p>only for 1D data right now</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">A new nddata object with an axis labeled <cite>values</cite>, and data corresponding to the CDF.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.chunk">
<code class="descname">chunk</code><span class="sig-paren">(</span><em>axisin</em>, <em>*otherargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>“Chunking” is defined here to be the opposite of taking a direct product, increasing the number of dimensions by the inverse of the process by which taking a direct product decreases the number of dimensions.  This function chunks axisin into multiple new axes arguments.:
axesout – gives the names of the output axes
shapesout – optional – if not given, it assumes equal length – if given, one of the values can be -1, which is assumed length</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.chunk_auto">
<code class="descname">chunk_auto</code><span class="sig-paren">(</span><em>axis_name</em>, <em>which_field</em>, <em>verbose=False</em>, <em>dimname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.chunk_auto" title="Permalink to this definition">¶</a></dt>
<dd><p>assuming that axis “axis_name” is currently labeled with a structured array, choose one field (“which_field”) of that structured array to generate a new dimension
Note that for now, by definition, no error is allowed on the axes.
However, once I upgrade to using structured arrays to handle axis and data errors, I will want to deal with that appropriately here.</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.chunkoff">
<code class="descname">chunkoff</code><span class="sig-paren">(</span><em>axisin</em>, <em>newaxes</em>, <em>newshapes</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.chunkoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Break chunks off of the dimension given by <cite>axisin</cite>.</p>
<p>Specifically, subdivide it into several dimensions given by
the names <cite>newaxes</cite> with <cite>newshapes</cite>.  If the shape of the
data allows, retain <cite>axisin</cite> as the “outer” dimension.</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.contiguous">
<code class="descname">contiguous</code><span class="sig-paren">(</span><em>lambdafunc</em>, <em>axis=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Return contiguous blocks that satisfy the condition given by <cite>lambdafunc</cite></p>
<p>this function returns the start and stop positions along the
axis for the contiguous blocks for which lambdafunc returns
true
<strong>Currently only supported for 1D data</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">adapted from stackexchange post <a class="reference external" href="http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array">http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array</a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lambdafunc</strong> (<em>types.FunctionType</em>) – If only one argument (lambdafunc) is given,
then lambdafunc is
a function that accepts a copy of the current nddata object
(<cite>self</cite>) as the argument.
If two arguments are given,
the second is <cite>axis</cite>, and lambdafunc has two arguments,
<cite>self</cite> and the value of <cite>axis</cite>.</li>
<li><strong>axis</strong> (<em>{None</em><em>,</em><em>str}</em>) – the name of the axis along which you want to find contiguous
blocks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>retval</strong> – An <span class="math">\(N\times 2\)</span> matrix, where the <span class="math">\(N\)</span> rows correspond to pairs of axis
label that give ranges over which <cite>lambdafunc</cite> evaluates to <cite>True</cite>.
These are ordered according to descending range width.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>&gt; #{{{ debugging block
&gt; sum_for_contiguous = abs(forplot).mean(‘t1’)
&gt; fl.next(“test contiguous”)
&gt; forplot = sum_for_contiguous.copy().set_error(None)
&gt; fl.plot(forplot,alpha = 0.25,linewidth = 3)
&gt; print “this is what the max looks like”,0.5*sum_for_contiguous.set_error(None).runcopy(max,’t2’)
&gt; print sum_for_contiguous &gt; 0.5*sum_for_contiguous.runcopy(max,’t2’)
&gt; retval = sum_for_contiguous.contiguous(quarter_of_max,’t2’)
&gt; print “contiguous range / 1e6:”,retval/1e6
&gt; for j in range(retval.shape[0]):
&gt;     a,b = retval[j,:]
&gt;     fl.plot(forplot[‘t2’:(a,b)])
&gt; fl.show()
&gt; exit()
&gt; #}}}</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.contour">
<code class="descname">contour</code><span class="sig-paren">(</span><em>labels=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Contour plot – kwargs are passed to the matplotlib
<cite>contour</cite> function.</p>
<p>See docstring of <cite>figlist_var.image()</cite> for an example</p>
<dl class="attribute">
<dt id="pyspecdata.nddata.labels">
<code class="descname">labels</code><a class="headerlink" href="#pyspecdata.nddata.labels" title="Permalink to this definition">¶</a></dt>
<dd><p><em>boolean</em> – Whether or not the levels should be labeled.
Defaults to True</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.convolve">
<code class="descname">convolve</code><span class="sig-paren">(</span><em>axisname</em>, <em>filterwidth</em>, <em>convfunc=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a convolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axisname</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – apply the convolution along <cite>axisname</cite></li>
<li><strong>filterwidth</strong> (<em>double</em>) – width of the convolution function.</li>
<li><strong>convfunc</strong> (<em>function</em>) – A function that takes two arguments – the first are the axis coordinates and the second is <cite>filterwidth</cite>.
Default is a normalized Gaussian of width (<span class="math">\(\sigma\)</span>)
<cite>filterwidth</cite>
<span class="math">\(\frac{1}{2 \sigma^2}\exp\left( - \frac{x^2}{2 \sigma^2} \right)\)</span>
For example if you want a complex lorentzian with <cite>filterwidth</cite> controlled by the rate $R$,
<em>i.e.</em>
<span class="math">\(\frac{-1}{-i 2 \pi f - R}\)</span>
then <code class="docutils literal"><span class="pre">convfunc</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">f,R:</span> <span class="pre">-1./(-1j*2*pi*f-R)</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>data=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a full copy of this instance.</p>
<p>Because methods typically change the data in place, you might want to
use this frequently.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>boolean</em>) – <p>Default to True.
False doesn’t copy the data – this is for internal use,
<em>e.g.</em> when you want to copy all the metadata and perform a
calculation on the data.</p>
<p>The code for this also provides the definitive list of the
nddata metadata.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.cropped_log">
<code class="descname">cropped_log</code><span class="sig-paren">(</span><em>subplot_axes=None</em>, <em>magnitude=4</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.cropped_log" title="Permalink to this definition">¶</a></dt>
<dd><p>For the purposes of plotting, this generates a copy where I take the log, spanning “magnitude” orders of magnitude
This is designed to be called as abs(instance).cropped_log(), so it doesn’t make a copy</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>axis</em>, <em>extent</em>, <em>fill_with=0</em>, <em>tolerance=1e-05</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>axis</cite> is uniformly ascending with spacing <span class="math">\(dx\)</span>,
then extend by adding a point every <span class="math">\(dx\)</span> until the axis
includes the point <cite>extent</cite>.  Fill the newly created datapoints with <cite>fill_with</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – name of the axis to extend</li>
<li><strong>extent</strong> (<em>double</em>) – extend the axis <cite>axis</cite> out to this point</li>
<li><strong>fill_with</strong> (<em>double</em>) – fill the new data points with this value (defaults to 0)</li>
<li><strong>tolerance</strong> (<em>double</em>) – when checking for ascending axis labels, etc.,
values/differences must match to within tolerance
(assumed to represent the actual precision, given
various errors, etc.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.extend_for_shear">
<code class="descname">extend_for_shear</code><span class="sig-paren">(</span><em>altered_axis</em>, <em>propto_axis</em>, <em>skew_amount</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.extend_for_shear" title="Permalink to this definition">¶</a></dt>
<dd><p>this is propto_axis helper function for <cite>.fourier.shear</cite></p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.fld">
<code class="descname">fld</code><span class="sig-paren">(</span><em>dict_in</em>, <em>noscalar=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.fld" title="Permalink to this definition">¶</a></dt>
<dd><p>flatten dictionary – return list.  This is the inverse of <a class="reference internal" href="#pyspecdata.nddata.mkd" title="pyspecdata.nddata.mkd"><code class="xref py py-func docutils literal"><span class="pre">nddata.mkd()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.fourier_shear">
<code class="descname">fourier_shear</code><span class="sig-paren">(</span><em>altered_axis</em>, <em>propto_axis</em>, <em>by_amount</em>, <em>zero_fill=False</em>, <em>start_in_conj=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.fourier_shear" title="Permalink to this definition">¶</a></dt>
<dd><p>the fourier shear method – see .shear() documentation</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.fromaxis">
<code class="descname">fromaxis</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.fromaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an nddata object from one of the axis labels.</p>
<p>Can be used in one of several ways:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self.fromaxis('axisname')</span></code>: Returns an nddata where <cite>retval.data</cite> consists of the given axis values.</li>
<li><code class="docutils literal"><span class="pre">self.fromaxis('axisname',inputfunc)</span></code>: use <cite>axisname</cite> as the input for <cite>inputfunc</cite>, and load the result into <cite>retval.data</cite></li>
<li><code class="docutils literal"><span class="pre">self.fromaxis(inputsymbolic)</span></code>: Evaluate <cite>inputsymbolic</cite> and load the result into <cite>retval.data</cite></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axisname</strong> (<em>str | list</em>) – The axis (or list of axes) to that is used as the argument of <cite>inputfunc</cite> or the function represented by <cite>inputsymbolic</cite>.
If this is the only argument, it cannot be a list.</li>
<li><strong>inputsymbolic</strong> (<em>sympy.Expr</em>) – A sympy expression whose only symbols are the names of axes.
It is preferred, though not required, that this is passed
without an <cite>axisname</cite> argument – the axis names are then
inferred from the symbolic expression.</li>
<li><strong>inputfunc</strong> (<em>function</em>) – A function (typically a lambda function) that taxes the values of the axis given by <cite>axisname</cite> as input.</li>
<li><strong>overwrite</strong> (<em>bool</em>) – Defaults to <cite>False</cite>. If set to <cite>True</cite>, it overwrites <cite>self</cite> with <cite>retval</cite>.</li>
<li><strong>as_array</strong> (<em>bool</em>) – Defaults to <cite>False</cite>. If set to <cite>True</cite>, <cite>retval</cite> is a properly dimensioned numpy ndarray rather than an nddata.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>retval</strong> – An expression calculated from the axis(es) given by <cite>axisname</cite> or inferred from <cite>inputsymbolic</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">nddata | ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.ft">
<code class="descname">ft</code><span class="sig-paren">(</span><em>axes</em>, <em>tolerance=1e-05</em>, <em>cosine=False</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ft" title="Permalink to this definition">¶</a></dt>
<dd><p>This performs a Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</p>
<dl class="docutils">
<dt>It adjusts normalization and units so that the result conforms to</dt>
<dd><span class="math">\(\tilde{s}(f)=\int_{x_min}^{x_max} s(t) e^{-i 2 \pi f t} dt\)</span></dd>
</dl>
<p>Note that while the analytical integral this corresponds to is normalized, performing
<a class="reference internal" href="#pyspecdata.nddata.ft" title="pyspecdata.nddata.ft"><code class="xref py py-func docutils literal"><span class="pre">ft()</span></code></a> followed by <a class="reference internal" href="#pyspecdata.nddata.ift" title="pyspecdata.nddata.ift"><code class="xref py py-func docutils literal"><span class="pre">ift()</span></code></a> on a discrete sequence is NOT completely invertible
(due to integration of the implied comb function??),
and would require division by a factor of $Delta f$ (the spectral width) in order
to retrieve the original function</p>
<p><strong>pre-FT</strong>, we use the axis to cyclically permute <span class="math">\(t=0\)</span> to the first index</p>
<p><strong>post-FT</strong>, we assume that the data has previously been IFT’d
If this is the case, passing <code class="docutils literal"><span class="pre">shift=True</span></code> will cause an error
If this is not the case, passing <code class="docutils literal"><span class="pre">shift=True</span></code> generates a standard fftshift
<code class="docutils literal"><span class="pre">shift=None</span></code> will choose True, if and only if this is not the case</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pad</strong> (<em>int</em><em> or </em><em>boolean</em>) – <cite>pad</cite> specifies a zero-filling.  If it’s a number, then it gives
the length of the zero-filled dimension.  If it is just <cite>True</cite>,
then the size of the dimension is determined by rounding the
dimension size up to the nearest integral power of 2.</li>
<li><strong>automix</strong> (<em>double</em>) – <cite>automix</cite> can be set to the approximate frequency value.  This is
useful for the specific case where the data has been captured on a
sampling scope, and it’s severely aliased over.</li>
<li><strong>cosine</strong> (<em>boolean</em>) – yields a sum of the fft and ifft, for a cosine transform</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.ft_clear_startpoints">
<code class="descname">ft_clear_startpoints</code><span class="sig-paren">(</span><em>axis</em>, <em>t=None</em>, <em>f=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ft_clear_startpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>clears memory of where the origins in the time and frequency domain are this is useful, e.g. when you want to ift and center about time=0 by setting shift=True you can also manually set the points:
keyword arguments <cite>t</cite> and <cite>f</cite> can be set by (1) manually setting the start point (2) using the string ‘current’ to leave the current setting alone or (3) None, which clears the startpoint</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.ft_state_to_str">
<code class="descname">ft_state_to_str</code><span class="sig-paren">(</span><em>*axes</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ft_state_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string that lists the FT domain for the given axes.</p>
<p><span class="math">\(u\)</span> refers to the original domain (typically time) and <span class="math">\(v\)</span> refers to the FT’d domain (typically frequency)
If no axes are passed as arguments, it does this for all axes.</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.ftshift">
<code class="descname">ftshift</code><span class="sig-paren">(</span><em>axis</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ftshift" title="Permalink to this definition">¶</a></dt>
<dd><p>FT-based shift.  Currently only works in time domain.</p>
<p>This was previously made obsolete, but is now a demo of how to use the ft properties.
It is not the most efficient way to do this.</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.get_covariance">
<code class="descname">get_covariance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>this returns the covariance matrix of the data</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.get_error">
<code class="descname">get_error</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_error" title="Permalink to this definition">¶</a></dt>
<dd><p>get a copy of the errors
either set_error(‘axisname’,error_for_axis) or set_error(error_for_data)</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.get_ft_prop">
<code class="descname">get_ft_prop</code><span class="sig-paren">(</span><em>axis</em>, <em>propname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_ft_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the FT property given by <cite>propname</cite>.  For both setting and getting, <cite>None</cite> is equivalent to an unset value if no <cite>propname</cite> is given, this just sets the <cite>FT</cite> property, which tells if a dimension is frequency or time domain</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.get_prop">
<code class="descname">get_prop</code><span class="sig-paren">(</span><em>propname</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>return arbitrary ND-data properties (typically acquisition parameters <em>etc.</em>) by name (<cite>propname</cite>)</p>
<p>In order to allow ND-data to store acquisition parameters and other info that accompanies the data,
but might not be structured in a gridded format, nddata instances
always have a <cite>other_info</cite> dictionary attribute,
which stores these properties by name.</p>
<p>If the property doesn’t exist, this returns <cite>None</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>propname</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – name of the property that you’re want returned</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">The value of the property (can by any type) or <cite>None</cite> if the property doesn’t exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.hdf5_write">
<code class="descname">hdf5_write</code><span class="sig-paren">(</span><em>h5path</em>, <em>directory='.'</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.hdf5_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the nddata to an HDF5 file.</p>
<p><cite>h5path</cite> is the name of the file followed by the node path where
you want to put it – it does <strong>not</strong> include the directory where
the file lives.
The directory can be passed to the <cite>directory</cite> argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h5path</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – The name of the file followed by the node path where
you want to put it – it does <strong>not</strong> include the directory where
the file lives.
(Because HDF5 files contain an internal directory-like group
structure.)</li>
<li><strong>directory</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – the directory where the HDF5 file lives.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.hdf_save_dict_to_group">
<code class="descname">hdf_save_dict_to_group</code><span class="sig-paren">(</span><em>group</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.hdf_save_dict_to_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Copied as-is from ACERT hfesr code
All numpy arrays are datasets.</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.ift">
<code class="descname">ift</code><span class="sig-paren">(</span><em>axes</em>, <em>tolerance=1e-05</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ift" title="Permalink to this definition">¶</a></dt>
<dd><p>This performs a Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</p>
<dl class="docutils">
<dt>It adjusts normalization and units so that the result conforms to</dt>
<dd><span class="math">\(s(t)=\int_{x_min}^{x_max} \tilde{s}(t) e^{i 2 \pi f t} df\)</span></dd>
</dl>
<p>Note that while the analytical integral this corresponds to is normalized, performing
<a class="reference internal" href="#pyspecdata.nddata.ft" title="pyspecdata.nddata.ft"><code class="xref py py-func docutils literal"><span class="pre">ft()</span></code></a> followed by <a class="reference internal" href="#pyspecdata.nddata.ift" title="pyspecdata.nddata.ift"><code class="xref py py-func docutils literal"><span class="pre">ift()</span></code></a> on a discrete sequence is NOT completely invertible
(due to integration of the implied comb function??),
and would require division by a factor of $Delta f$ (the spectral width) in order
to retrieve the original function</p>
<p><strong>pre-IFT</strong>, we use the axis to cyclically permute $f=0$ to the first index</p>
<p><strong>post-IFT</strong>, we assume that the data has previously been FT’d
If this is the case, passing <code class="docutils literal"><span class="pre">shift=True</span></code> will cause an error
If this is not the case, passing <code class="docutils literal"><span class="pre">shift=True</span></code> generates a standard ifftshift
<code class="docutils literal"><span class="pre">shift=None</span></code> will choose True, if and only if this is not the case</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pad</strong> (<em>int</em><em> or </em><em>boolean</em>) – <p><cite>pad</cite> specifies a zero-filling.  If it’s a number, then it gives
the length of the zero-filled dimension.  If it is just <cite>True</cite>,
then the size of the dimension is determined by rounding the
dimension size up to the nearest integral power of 2.   It uses the
<cite>start_time</cite> ft property to determine the start of the axis.  To
do this, it assumes that it is a stationary signal
(convolved with infinite comb function).
The value of <cite>start_time</cite> can differ from by a non-integral multiple of
<span class="math">\(\Delta t\)</span>, though the routine will check whether or not it is safe to
do this.</p>
<dl class="docutils">
<dt>..note ::</dt>
<dd>In the code, this is controlled by <cite>p2_post</cite> (the integral
<span class="math">\(\Delta t\)</span> and <cite>p2_post_discrepancy</cite> – the non-integral.</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyspecdata.nddata.imag">
<code class="descname">imag</code><a class="headerlink" href="#pyspecdata.nddata.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imag component of the data</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.indices">
<code class="descname">indices</code><span class="sig-paren">(</span><em>axis_name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string of indeces that most closely match the axis labels corresponding to values. Filter them to make sure they are unique.</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.inhomog_coords">
<code class="descname">inhomog_coords</code><span class="sig-paren">(</span><em>direct_dim</em>, <em>indirect_dim</em>, <em>tolerance=1e-05</em>, <em>method='linear'</em>, <em>plot_name=None</em>, <em>fl=None</em>, <em>debug_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.inhomog_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the “inhomogeneity transform,” which rotates the data by <span class="math">\(45^{\circ}\)</span>, and then mirrors the portion with <span class="math">\(t_2&lt;0\)</span> in order to transform from a <span class="math">\((t_1,t_2)\)</span> coordinate system to a <span class="math">\((t_{inh},t_{homog})\)</span> coordinate system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>direct_dim</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – Label of the direct dimension (typically <span class="math">\(t_2\)</span>)</li>
<li><strong>indirect_dim</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – Label of the indirect dimension (typically <span class="math">\(t_1\)</span>)</li>
<li><strong>method</strong> (<em>'linear'</em><em>, </em><em>'fourier'</em>) – The interpolation method used to rotate the data and to mirror the data.
<strong>Note</strong> currently, both use a fourier-based mirroring method.</li>
<li><strong>plot_name</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – the base name for the plots that are generated</li>
<li><strong>fl</strong> (<em>figlist_var</em>) – </li>
<li><strong>debug_kwargs</strong> (<em>dict</em>) – <p>with keys:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2"><cite>correct_overlap</cite>:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">if False, doesn’t correct for the overlap error that occurs during mirroring</td>
</tr>
</tbody>
</table>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.integrate">
<code class="descname">integrate</code><span class="sig-paren">(</span><em>thisaxis</em>, <em>backwards=False</em>, <em>cumulative=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>this performs an integration – which is similar to a sum, except that it takes the axis into account, i.e., it performs:
$int f(x) dx$
rather than
$sum_i f(x_i)$</p>
<p>Gaussian quadrature, etc, is planned for a future version.</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.interp">
<code class="descname">interp</code><span class="sig-paren">(</span><em>axis</em>, <em>axisvalues</em>, <em>past_bounds=None</em>, <em>verbose=False</em>, <em>return_func=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.interp" title="Permalink to this definition">¶</a></dt>
<dd><p>interpolate data values given axis values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>return_func</strong> (<em>boolean</em>) – defaults to False.  If True, it returns a function that accepts
axis values and returns a data value.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.invinterp">
<code class="descname">invinterp</code><span class="sig-paren">(</span><em>axis</em>, <em>values</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.invinterp" title="Permalink to this definition">¶</a></dt>
<dd><p>interpolate axis values given data values</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">labels</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span></dt>
<dd><p>label the dimensions, given in listofstrings with the axis labels given in listofaxes – listofaxes must be a numpy array;
you can pass either a dictionary or a axis name (string)/axis label (numpy array) pair</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.linear_shear">
<code class="descname">linear_shear</code><span class="sig-paren">(</span><em>along_axis</em>, <em>propto_axis</em>, <em>shear_amnt</em>, <em>zero_fill=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.linear_shear" title="Permalink to this definition">¶</a></dt>
<dd><p>the linear shear – see <cite>self.shear</cite> for documentation</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.matchdims">
<code class="descname">matchdims</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.matchdims" title="Permalink to this definition">¶</a></dt>
<dd><p>add any dimensions to self that are not present in other</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.matrices_3d">
<code class="descname">matrices_3d</code><span class="sig-paren">(</span><em>also1d=False</em>, <em>invert=False</em>, <em>max_dimsize=1024</em>, <em>downsample_self=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.matrices_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>returns X,Y,Z,x_axis,y_axis
matrices X,Y,Z, are suitable for a variety of mesh plotting, etc, routines
x_axis and y_axis are the x and y axes</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.mayavi_surf">
<code class="descname">mayavi_surf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mayavi_surf" title="Permalink to this definition">¶</a></dt>
<dd><p>use the mayavi surf function, assuming that we’ve already loaded mlab
during initialization</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the mean and set the error to the standard deviation</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.mean_all_but">
<code class="descname">mean_all_but</code><span class="sig-paren">(</span><em>listofdims</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mean_all_but" title="Permalink to this definition">¶</a></dt>
<dd><p>take the mean over all dimensions not in the list</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.mean_weighted">
<code class="descname">mean_weighted</code><span class="sig-paren">(</span><em>axisname</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mean_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>perform  the weighted mean along <cite>axisname</cite> (use $sigma$ from $sigma = $self.get_error() do generate $1/sigma$ weights)
for now, it clears the error of <cite>self</cite>, though it would be easy to calculate the new error, since everything is linear</p>
<p>unlike other functions, this creates working objects that are themselves nddata objects
this strategy is easier than coding out the raw numpy math, but probably less efficient</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.meshplot">
<code class="descname">meshplot</code><span class="sig-paren">(</span><em>stride=None</em>, <em>alpha=1.0</em>, <em>onlycolor=False</em>, <em>light=None</em>, <em>rotation=None</em>, <em>cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;</em>, <em>ax=None</em>, <em>invert=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.meshplot" title="Permalink to this definition">¶</a></dt>
<dd><p>takes both rotation and light as elevation, azimuth
only use the light kwarg to generate a black and white shading display</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.mkd">
<code class="descname">mkd</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mkd" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an internal function that accepts one of the internal attributes (axis_coords, etc) that are stored as lists, and return a list that is labeled with the dimlabels.</p>
<p>Note that the inverse of this function is <code class="xref py py-func docutils literal"><span class="pre">self.fld()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.name" title="Permalink to this definition">¶</a></dt>
<dd><p>args:
.name(newname) –&gt; Name the object (for storage, etc)
.name() –&gt; Return the name</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.plot_labels">
<code class="descname">plot_labels</code><span class="sig-paren">(</span><em>labels</em>, <em>fmt=None</em>, <em>**kwargs_passed</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.plot_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>this only works for one axis now</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.polyfit">
<code class="descname">polyfit</code><span class="sig-paren">(</span><em>axis</em>, <em>order=1</em>, <em>force_y_intercept=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.polyfit" title="Permalink to this definition">¶</a></dt>
<dd><p>return the coefficients and the fit –&gt; later, should probably branch this off as a new type of fit class</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.random_mask">
<code class="descname">random_mask</code><span class="sig-paren">(</span><em>axisname</em>, <em>threshold=0.36787944117144233</em>, <em>inversion=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.random_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a random mask with about ‘threshold’ of the points thrown out</p>
</dd></dl>

<dl class="attribute">
<dt id="pyspecdata.nddata.real">
<code class="descname">real</code><a class="headerlink" href="#pyspecdata.nddata.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real component of the data</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.register_axis">
<code class="descname">register_axis</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.register_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate the data so that the given axes are in register with a set of specified values. Does not change the spacing of the axis labels.</p>
<p>It finds the axis label position that is closest to the values given in <cite>arg</cite>, then interpolates (Fourier/sinc method) the data onto a new, slightly shifted, axis that passes exactly through the value given.
To do this, it uses
<code class="xref py py-func docutils literal"><span class="pre">.ft_clear_startpoints()</span></code>
and uses
<code class="xref py py-func docutils literal"><span class="pre">.set_ft_prop()</span></code>
to override the “not aliased” flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg</strong> (<em>dict</em><em> (</em><em>key</em><em>,</em><em>value = str</em><em>,</em><em>double</em><em>)</em>) – A list of the dimensions that you want to place in register, and the values you want them registered to.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.reorder">
<code class="descname">reorder</code><span class="sig-paren">(</span><em>*axes</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder the dimensions
the first arguments are a list of dimensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*axes</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – Accept any number of arguments that gives the dimensions, in the
order that you want thee.</li>
<li><strong>first</strong> (<em>bool</em>) – (default True)
Put this list of dimensions first, while False puts them last (where they then come in the order given).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.run_avg">
<code class="descname">run_avg</code><span class="sig-paren">(</span><em>thisaxisname</em>, <em>decimation=20</em>, <em>centered=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.run_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>a simple running average</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.secsy_transform">
<code class="descname">secsy_transform</code><span class="sig-paren">(</span><em>direct_dim</em>, <em>indirect_dim</em>, <em>has_indirect=True</em>, <em>method='fourier'</em>, <em>truncate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.secsy_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the time-domain data backwards by the echo time.</p>
<p>As opposed to <code class="xref py py-func docutils literal"><span class="pre">secsy_transform_manual</span></code>, this calls on on <code class="xref py py-func docutils literal"><span class="pre">skew</span></code>,
rather than directly manipulating the phase of the function, which can lead to aliasing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>has_indirect</strong> (<em>bool</em>) – <p>(This option is largely specific to data loaded by <code class="xref py py-func docutils literal"><span class="pre">acert_hdf5</span></code>)</p>
<p>Does the data actually have an indirect dimension?
If not, assume that there is a constant echo time,
that can be retrieved with <code class="docutils literal"><span class="pre">.get_prop('te')</span></code>.</p>
</li>
<li><strong>truncate</strong> (<em>bool</em>) – If this is set, <cite>register_axis &lt;pyspecdata.axis_manipulation.register_axis&gt;</cite> to <span class="math">\(t_{direct}=0\)</span>,
and then throw out the data for which <span class="math">\(t_{direct}&lt;0\)</span>.</li>
<li><strong>method</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – The shear method (linear or fourier).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.secsy_transform_manual">
<code class="descname">secsy_transform_manual</code><span class="sig-paren">(</span><em>direct_dim</em>, <em>indirect_dim</em>, <em>has_indirect=True</em>, <em>truncate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.secsy_transform_manual" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the time-domain data backwards by the echo time.
As opposed to <code class="xref py py-func docutils literal"><span class="pre">secsy_transform</span></code>, this directlly manipulates the phase of the function, rather than calling on <code class="xref py py-func docutils literal"><span class="pre">skew</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>has_indirect</strong> (<em>bool</em>) – <p>(This option is largely specific to data loaded by <code class="xref py py-func docutils literal"><span class="pre">acert_hdf5</span></code>)</p>
<p>Does the data actually have an indirect dimension?
If not, assume that there is a constant echo time,
that can be retrieved with <code class="docutils literal"><span class="pre">.get_prop('te')</span></code>.</p>
</li>
<li><strong>truncate</strong> (<em>bool</em>) – If this is set, <cite>register_axis &lt;pyspecdata.axis_manipulation.register_axis&gt;</cite> to <span class="math">\(t_{direct}=0\)</span>,
and then throw out the data for which <span class="math">\(t_{direct}&lt;0\)</span>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.set_error">
<code class="descname">set_error</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.set_error" title="Permalink to this definition">¶</a></dt>
<dd><p>set the errors: either</p>
<p><cite>set_error(‘axisname’,error_for_axis)</cite> or <cite>set_error(error_for_data)</cite></p>
<p><cite>error_for_data</cite> can be a scalar, in which case, <strong>all</strong> the data errors are set to <cite>error_for_data</cite></p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.set_ft_prop">
<code class="descname">set_ft_prop</code><span class="sig-paren">(</span><em>axis</em>, <em>propname=None</em>, <em>value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.set_ft_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the FT property given by <cite>propname</cite>.  For both setting and getting, <cite>None</cite> is equivalent to an unset value if <cite>propname</cite> is a boolean, and <cite>value</cite> is True (the default), it’s assumed that propname is actually None, and that <cite>value</cite> is set to the <cite>propname</cite> argument (this allows us to set the <cite>FT</cite> property more easily)</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.set_prop">
<code class="descname">set_prop</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.set_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>set a ‘property’ of the nddata
This is where you can put all unstructured information (e.g. experimental parameters, etc)</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.setaxis">
<code class="descname">setaxis</code><span class="sig-paren">(</span><em>axis</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.setaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>set the value of the axis if you pass a function as the <cite>value</cite>, it will use the existing axis labels as the argument of the function, and then put the result into the axis labels</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.shear">
<code class="descname">shear</code><span class="sig-paren">(</span><em>along_axis</em>, <em>propto_axis</em>, <em>shear_amnt</em>, <em>zero_fill=True</em>, <em>start_in_conj=False</em>, <em>method='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Shear the data <span class="math">\(s\)</span>:</p>
<p><span class="math">\(s(x',y,z) = s(x+ay,y,z)\)</span></p>
<p>where <span class="math">\(x\)</span> is the <cite>altered_axis</cite> and <span class="math">\(y\)</span> is the
<cite>propto_axis</cite>.  (Actually typically 2D, but <span class="math">\(z\)</span> included
just to illustrate other dimensions that aren’t involved)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> (<em>{'fourier'</em><em>,</em><em>'linear'}</em>) – <dl class="docutils">
<dt>fourier</dt>
<dd>Use the Fourier shift theorem (<em>i.e.</em>, sinc interpolation).  A
shear is equivalent to the following in the conjugate domain:<p>..math: <cite>tilde{s}(f_x,f’_y,z) = tilde{s}(f_x,f_y-af_x,f_z)</cite></p>
<p class="last">Because of this, the algorithm <strong>also</strong>
automatically <cite>extend`s the data in `f_y</cite> axis.
Equivalently, it increases the resolution
(decreases the interval between points) in the
<cite>propto_axis</cite> dimension.  This prevents aliasing
in the conjugate domain, which will corrupt the
data <em>w.r.t.</em> successive transformations. It does
this whether or not <cite>zero_fill</cite> is set
(<cite>zero_fill</cite> only controls filling in the
“current” dimension)</p>
</dd>
<dt>linear</dt>
<dd>Use simple linear interpolation.</dd>
</dl>
</li>
<li><strong>altered_axis</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – The coordinate for which data is altered, <em>i.e.</em>
..math: <cite>x</cite> such that ..math: <cite>f(x+ay,y)</cite>.</li>
<li><strong>by_amount</strong> (<em>double</em>) – The amount of the shear (..math: <cite>a</cite> in the previous)</li>
<li><strong>propto_axis</strong> (<a class="reference internal" href="units.html#pyspecdata.units.units.str" title="pyspecdata.units.units.str"><em>str</em></a>) – The shift along the <cite>altered_axis</cite> dimension is
proportional to the shift along <cite>propto_axis</cite>.
The position of data relative to the <cite>propto_axis</cite> is not
changed.
Note that by the shift theorem, in the frequency domain,
an equivalent magnitude, opposite sign, shear is applied
with the <cite>propto_axis</cite> and <cite>altered_axis</cite> dimensions
flipped.</li>
<li><strong>start_in_conj</strong> (<em>{False</em><em>, </em><em>True}</em><em>, </em><em>optional</em>) – <p>Defaults to False</p>
<p>For efficiency, one can replace a double (I)FT call followed by a
shear call with a single shear call where <cite>start_in_conj</cite> is set.</p>
<p><cite>self</cite> before the call is given in the conjugate domain  (<em>i.e.</em>,
<span class="math">\(f\)</span> <em>vs.</em> <span class="math">\(t\)</span>) along both dimensions from the one that’s
desired.  This means: (1) <cite>self</cite> after the function call transformed
into the conjugate domain from that before the call and (2)
<cite>by_amount</cite>, <cite>altered_axis</cite>, and <cite>propto_axis</cite> all refer to the shear
in the conjugate domain that the data is in at the end of the
function call.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.smoosh">
<code class="descname">smoosh</code><span class="sig-paren">(</span><em>dimstocollapse</em>, <em>dimname=0</em>, <em>noaxis=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.smoosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Collapse multiple dimensions into one dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimstocollapse</strong> (<em>list of strings</em>) – the dimensions you want to collapse to one</li>
<li><strong>dimname</strong> (<em>None</em><em>, </em><em>string</em><em>, </em><em>integer</em>) – <p>if dimname is:</p>
<ul>
<li>None: create a new (direct product) name,</li>
<li>a number: lump the existing dimension into the number given, in the list</li>
<li>a string: same as the previous, where the string can be part of the list or not</li>
</ul>
</li>
<li><strong>noaxis</strong> (<em>bool</em>) – if set, then just skip calculating the axis for the new dimension,
which otherwise is typically a complicated record array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>squeeze singleton dimensions – return a list of the labels for the axes that are dropped</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.to_ppm">
<code class="descname">to_ppm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.to_ppm" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that converts from Hz to ppm using Bruker parameters</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.unitify_axis">
<code class="descname">unitify_axis</code><span class="sig-paren">(</span><em>axis_name</em>, <em>is_axis=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.unitify_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>this just generates an axis label with appropriate units</p>
</dd></dl>

<dl class="method">
<dt id="pyspecdata.nddata.unset_prop">
<code class="descname">unset_prop</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.unset_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a ‘property’</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="axis_manipulation.html" class="btn btn-neutral float-right" title="Axis Manipulation Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="notebook.html" class="btn btn-neutral" title="LaTeX Notebook Functionality" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, John M. Franck.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.9.5.1.6',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>